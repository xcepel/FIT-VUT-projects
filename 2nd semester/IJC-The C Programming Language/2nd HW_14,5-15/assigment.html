<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 3.0//EN//">
<!-- saved from url=(0057)http://www.fit.vutbr.cz/study/courses/IJC/public/DU2.html -->
<html version="3"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-2">
    
    <meta http-equiv="Content-language" content="cs">
    <title>IJC: DU2 </title>
<style type="text/css">@font-face {
    font-family: 'OpenSansPP';
    font-style: normal;
    font-weight: 400;
    src: local('Open Sans Regular'), local('OpenSans-Regular'), url(https://fonts.gstatic.com/s/opensans/v15/u-WUoqrET9fUeobQW7jkRYX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
    unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
    font-family: 'OpenSansPP';
    font-style: normal;
    font-weight: 700;
    src: local('Open Sans Bold'), local('OpenSans-Bold'), url(https://fonts.gstatic.com/s/opensans/v15/k3k702ZOKiLJc3WVjuplzIjoYw3YTyktCCer_ilOlhE.woff2) format('woff2');
    unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+20A0-20AB, U+20AD-20CF, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
    font-family: 'OpenSansPP';
    font-style: normal;
    font-weight: 700;
    src: local('Open Sans Bold'), local('OpenSans-Bold'), url(https://fonts.gstatic.com/s/opensans/v15/k3k702ZOKiLJc3WVjuplzBampu5_7CjHW5spxoeN3Vs.woff2) format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2212, U+2215;
}
@font-face {
    font-family: 'OpenSansPP';
    font-style: normal;
    font-weight: 400;
    src: local('Open Sans Regular'), local('OpenSans-Regular'), url(https://fonts.gstatic.com/s/opensans/v15/cJZKeOuBrn4kERxqtaUH3ZBw1xU1rKptJj_0jans920.woff2) format('woff2');
    unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2212, U+2215;
}

#pp-2box, #pp-2box-small {
    position: fixed !important;
    display: block;
    right: 23px;
    bottom: 23px;
    z-index: 2147483647;
    width: 450px;
    height: auto !important;
    padding: 0;
    margin: 0;
    border: none;
    border-radius: 7px;
    box-shadow: 0 6px 40px rgba(0, 0, 0, 0.3);
    background-color: #FFF;
}

#pp-2box>.pp-icon, #pp-2box-small>.pp-icon {
    position: absolute !important;
    display: block !important;
    top: 14px;
    left: -9px;
    width: 64px;
    height: 64px;
    padding: 0;
    margin: 0;
    border: none;
    background-color: transparent !important;
    background-image: url(data:image/png;base64,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);
    background-repeat: no-repeat;
}

#pp-2box>.close, #pp-2box-small>.close  {
    position: absolute !important;
    display: block !important;
    top: 10px;
    right: 10px;
    width: 18px;
    height: 18px;
    padding: 0;
    margin: 0;
    border: none;
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASBAMAAACk4JNkAAAAAXNSR0IB2cksfwAAAC1QTFRFAAAA7+/37fH37vH47vH37+/07vL37vH27vD3rLjN1Nrm7fH3qLTK7vL27vH3sn2xfQAAAA90Uk5TAECfz/8wv+/A//+g/9Dw5R3l7wAAAHtJREFUeJxjYGBgVHYxEmAAAtYUFxcXtwAgK9wFBEqBQiVglnsAA4cLBCQwiLh4LnHxmuLiyLDFxeuUy5olLt4MV1xc1qw65eLizABU4nVmCZBEYsFkfZF0IEyBmdzAwPoEzPADOiEOzHoKclULkOEBchUD416X20CXAgAA3TJgepJfkQAAAABJRU5ErkJggg==);
    background-repeat: no-repeat;
    background-color: transparent !important;
    cursor: pointer;
}

#pp-2box>.pp-headline, #pp-2box-small>.pp-headline {
    display: block !important;
    width: auto !important;
    height: auto !important;
    line-height: 45px;
    padding: 11px 18px 0 69px;
    margin: 0;
    border: none;
    font-family: 'OpenSansPP',  sans-serif !important;
    font-size: 24px;
    font-weight: 700;
    text-transform: none;
    text-align: left;
    color: #00b9ff;
    background: none !important;
}

#pp-2box>.pp-content {
    display: block !important;
    width: auto !important;
    min-width: 0 !important;
    max-width: none !important;
    height: auto !important;
    min-height: 0 !important;
    max-height: none !important;
    line-height: 22px;
    padding: 0 10px 17px 69px;
    margin: -7px 0 0 0;
    border: none;
    font-family: 'OpenSansPP', sans-serif !important;
    font-size: 14px;
    font-weight: 400;
    text-transform: none;
    text-align: left;
    color: #2e3337;
    background: none !important;
}

#pp-2box>.pp-content>b {
    display: inline !important;
    width: auto !important;
    height: auto !important;
    padding: 0;
    margin: 0;
    border: none;
    font-family: 'OpenSansPP', sans-serif !important;
    font-size: 17px;
    font-weight: 700;
    text-transform: none;
    text-align: left;
    color: #2e3337;
    background: none !important;
}

#pp-2box>.pp-footer {
    display: table !important;
    width: 100%;
    height: auto !important;
    padding: 23px 0;
    margin: 0;
    border-top: 1px solid #dbdbdb;
    border-right: none;
    border-bottom: none;
    border-left: none;
    border-bottom-right-radius: 5px;
    border-bottom-left-radius: 5px;
    background: #f4f4f4 !important;
}

#pp-2box>.pp-footer>.pp-left-part {
    display: block !important;
    box-sizing: border-box !important;
    float: left;
    width: 50%;
    height: auto !important;
    padding-left: 15px;
    padding-right: 20px;
    padding-top: 0;
    padding-bottom: 0;
    margin: 0;
    border: none;
    text-align: center;
    background: none !important;
}

#pp-2box>.pp-footer>.pp-left-part>.pp-big-text {
    display: block !important;
    width: auto !important;
    height: auto !important;
    line-height: 35px;
    padding: 0;
    margin: 0;
    border: none;
    font-family: 'OpenSansPP', sans-serif !important;
    font-size: 40px;
    font-weight: 400;
    text-transform: none;
    text-align: center;
    color: #2e3337;
    background: none !important;
}

#pp-2box>.pp-footer>.pp-left-part>.pp-big-text>b {
    display: inline !important;
    width: auto !important;
    height: auto !important;
    padding: 0;
    margin: 0;
    border: none;
    font-family: 'OpenSansPP', sans-serif !important;
    font-size: 40px;
    font-weight: 800;
    text-transform: none;
    text-align: right;
    color: #2e3337;
    background: none !important;
}

#pp-2box>.pp-footer>.pp-left-part>.pp-small-text {
    display: block !important;
    width: auto !important;
    height: auto !important;
    padding: 0;
    margin: 0;
    border: none;
    font-family: 'OpenSansPP', sans-serif !important;
    font-size: 13px;
    color: #2e3337;
    text-transform: none;
    text-align: center;
    background: none !important;
}

#pp-2box>.pp-footer>.pp-right-part {
    display: block !important;
    box-sizing: border-box !important;
    float: right;
    width: 50%;
    height: auto !important;
    padding-right: 15px;
    padding-left: 0;
    padding-top: 0;
    padding-bottom: 0;
    margin: 0;
    border: none;
    text-transform: none;
    background: none !important;
}

#pp-2box>.pp-footer>.pp-right-part>.btn {
    display: block !important;
    width: 100%;
    height: auto !important;
    line-height: 20px !important;
    padding: 13px 0;
    margin: 0;
    border: none;
    border-radius: 5px;
    box-shadow: none;
    background-color: #7fb93c !important;
    background-image: linear-gradient(-45deg, rgba(136, 196, 66, 0.84) 0%, rgba(127, 185, 60, 0.84) 100%) !important;
    color: #FFF;
    font-family: 'OpenSansPP', sans-serif !important;
    font-size: 18px;
    font-weight: 700;
    text-transform: uppercase;
    text-align: center;
    text-decoration: none;
    transition: all 0.2s linear;
}

#pp-2box>.pp-footer>.pp-right-part>.btn:hover {
    background: #2badce !important;
}

/* cerveny content popup */
#pp-2box.pp-box-red>.pp-headline {
    color: #f00;
}

#pp-2box.pp-box-red>.pp-footer>.pp-right-part>.btn {
    background-image: none !important;
    background-color: #f00 !important;
}

/* maly box */
#pp-2box-small {
    width: 325px;
}

#pp-2box-small>.pp-icon {
    width: 50px;
    height: 50px;
    top: 10px;
    left: -10px;
    background-size: cover;
}

#pp-2box-small>.pp-headline {
    font-size: 24px;
    padding: 7px 0 2px 51px;
    line-height: normal;
}

#pp-2box-small>.pp-content {
    font-family: 'OpenSansPP', sans-serif !important;
    font-size: 12px;
    text-transform: none;
    text-align: left;
    color: #2e3337;
    margin-left: 51px !important;
    padding: 0 5px 12px 22px;
    background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IB2cksfwAAAN5QTFRFAAAAgLdAgLs9gLs+gbs9gbw+gL9Af7o8gLs9gbw+gbw9grw+gr0+gLo8gr0/gr0+g74/grw/g74/hb9Ag75A2OvDr9WEh79Agbw8gr1A0ee3////4/HUg78/hMA/gLw9hL5DyOKq6vTejMNNhL8/hcA/udqU4/DTh79Gv92c8PfnkcZUhcBAhcA/2uvG3+7Oh8BGtdiN9PnulcdahcFAgrw/6fTd/v79+Pv0mstihsFAhMBAgbw++/34oM1sh8FAiMFH3e3Kp9J3hsFBgb1AhcE/g74/hsBAg71Ah8FCLen9IgAAAEp0Uk5TACCPz//PIJD/////j9D//8///5D///8gkP///////9D//////8/////////////////////Q///////QkP//kP////+Q/9DQkJAte9JXAAAAwElEQVR4nE2P2RrBMBBGB0EJQYoiWlvsqpbaat95/xcyERf+q8yc72RmADChcISQaDgGv8SJkUhSTErXacMghCYoZZnsH89Rxjg30VdcdVi+UOTcgtLPZ+WKqNqOCTX061izhmi2pGwD8k63x1hfDIaOM3IB/bHwJlMxm0vpuj4sKO15Yrlabxw5coMt7NCfeGJ/+HL/CDE1/3S+KD/wrxbALcNxoy+/B0e16oPbtubBUx/z0tzXXMUyt/j/21LvD8APGFI1VKajAAAAAElFTkSuQmCC);
    background-repeat: no-repeat;
    background-position: 0 0;

}

.pp-search {
    display: block;
    margin: 2px 0 4px 0;
    font-family: Arial, Helvetica, sans-serif !important;
    font-weight: 700;
    text-decoration: none;
    color: #f67b10;
    line-height: 19px;
    font-size: 12px;
}

.pp-search:active,
.pp-search:hover,
.pp-search:focus,
.pp-search:visited,
.pp-search:link {
    text-decoration: none !important;
    color: #f67b10 !important;
}

.pp-search-zbozi {
    margin: 5px 0 0 0;
    font-size: 14px;
    padding: 0 !important;
    border: 0 !important;
}

.pp-search-heureka {
    font-size: 13px;
    margin: 5% 0 0;
}

.product-detail__shop-offers-button .button--blue {
    width: 100%;
}

.pp-search-pricemania.button--blue {
    width: 100%;
    background: #7fb93c;
    margin-top: 10px;
}

.pp-search-pricemania.button--blue:hover {
    background: #679b2a
}

.pp-search>span {
    padding: 3px 10px;
    border-radius: 2px;
    margin-right: 5px;
    background: #f67b10;
    color: #ffffff;
}

.pp-search.pp-search-heureka.pp-search-najnakup {
    margin-top: 10px;
    min-height: auto;
}

.pp-search.pp-search-heureka>span {
    border: 2px solid #679b2a;
    background: #7fb93c;
    border-radius: 4px;
    width: 134px;
    box-sizing: border-box;
    height: 35px;
    margin: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    line-height: 35px;
    padding: 0;
    margin-top: 5%;
}

.scope-heureka div.product div.wherebuy .price .pp-search.pp-search-heureka>span {
    font-size: 13px;
    color: #fff;
}

.pp-search.pp-search-heureka:hover>span {
    background: #679b2a;
}

.pp-search.pp-search-zbozi>span {
    border: 2px solid #679b2a;
    background-color: #fff;
    border-radius: 4px;
    color: #679b2a;
    width: 100%;
    box-sizing: border-box;
    height: 44px;
    line-height: 44px;
    margin: auto;
    display: flex;
    align-items: center;
    justify-content: center;
}

.pp-search.pp-search-zbozi:hover>span {
    background-color: #679b2a;
    color: #fff;
}

.pp-search>span>span, .pp-search-pricemania.button--blue>span>span {
    display: inline-block;
    padding: 5px;
    margin-right: 5px;
    background-size: cover;
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEGEiEfkWYJTQAAALpJREFUOMvN0jFKQ0EUheHvPFMq2LsFCwVLwUJiYWPtAt4GxB24GSs3oEVcgJ0gKQWJBFJrI1wbHwQRkXmNfzdw/8PcORO/UFWbOMIUh5jgOcnZMJNvwgYOcIJjbOEed5gleauqxyS7gzP5EvdwiX084BbnSV5/uNjH+iFV1eMK15j5O/MkT6mqF+xo4yJVVdp5HxugM5KWgNV6E12DfIqbIWT0Ci2PuML28An/RwvLEf6yQ49Fg7xA/wkw/D45daR6WgAAAABJRU5ErkJggg==')
}

.pp-search.pp-search-heureka>span>span {
    padding: 8px;
    margin-right: 6px;
}

.pp-search-zbozi>span>span {
    margin-right: 6px;
    padding: 8px;
    display: flex;
    margin-top: -1px;
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IB2cksfwAAAHhQTFRFAAAAgL9Afrg9f7g8gLk8gLk8f7g9VapVfbk8fro7gLk8f7k8f7k7f7o7gLMzgLk8gLo6gLk9f7o8gLo8frg8erg9frg9f7k8gLk9fLs+gLk8f7k8frk9gLk8gbo/hbxF2erF9/v0h71HvNqZ2erGgrtBfrk8f7k8yd54/gAAACh0Uk5TAAxLkMzQsQM3fcDNjkoK1DCk1aJdGWXoUCnk/3H2//////////9N5WnfXz8AAABbSURBVHicY2CAAEYmZhZWNiiHnYOTi5uHl4+BH8wVEBQSFhEFM1lBhJg4swQCSDIwSEmjABkGVL60LLqANH4BOXk0AQVFJVQBZRVVAmZgFxBH5YszqKkj89XVAB82FtoI5WUTAAAAAElFTkSuQmCC');
}

.pp-search-zbozi:hover>span>span {
    background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH4gEGEiEfkWYJTQAAALpJREFUOMvN0jFKQ0EUheHvPFMq2LsFCwVLwUJiYWPtAt4GxB24GSs3oEVcgJ0gKQWJBFJrI1wbHwQRkXmNfzdw/8PcORO/UFWbOMIUh5jgOcnZMJNvwgYOcIJjbOEed5gleauqxyS7gzP5EvdwiX084BbnSV5/uNjH+iFV1eMK15j5O/MkT6mqF+xo4yJVVdp5HxugM5KWgNV6E12DfIqbIWT0Ci2PuML28An/RwvLEf6yQ49Fg7xA/wkw/D45daR6WgAAAABJRU5ErkJggg==')
}
</style></head>

<body><h1>IJC: DU2</h1>

<hr>
<xmp>

Jazyk C                       DU2                      22.3.2022
----------------------------------------------------------------

                         Domácí úkol è.2


Termín odevzdání: 19.4.2022                       (Max. 15 bodù)

1) (max 5b)
   a) V jazyku C napi¹te program "tail.c", který  ze zadaného
   vstupního souboru vytiskne posledních  10 øádkù. Není-li
   zadán vstupní soubor, ète ze stdin. Je-li programu zadán
   parametr -n èíslo, bude se tisknout tolik posledních øádkù,
   kolik je zadáno parametrem 'èíslo' (bez znaménka).
   Pøípadná chybová hlá¹ení tisknìte do stderr. Pøíklady:

     tail soubor
     tail -n 20 <soubor

   [Poznámka: výsledky by mìly být +-stejné jako u POSIX tail]

   Je povolen implementaèní limit na délku øádku (napø. 4095 znakù),
   v pøípadì prvního pøekroèení mezí hlaste chybu na stderr (øádnì otestujte)
   a pokraèujte se zkrácenými øádky (zbytek øádku pøeskoèit/ignorovat).


2) (max 10b)
   Pøepi¹te následující C++ program do jazyka ISO C

    // wordcount-.cc
    // Pou¾ijte: g++ -O2
    // Pøíklad pou¾ití STL kontejneru unordered_map<>
    // Program poèítá èetnost slov ve vstupním textu,
    // slovo je cokoli oddìlené "bílým znakem"

    #include <string>
    #include <iostream>
    #include <unordered_map>

    int main() {
        using namespace std;
        unordered_map<string,int> m;  // asociativní pole
                     // mapuje klíè/string na hodnotu/int
        string word;
        while (cin >> word) // ètení slova (jako scanf "%s", ale bezpeèné)
            m[word]++;      // poèítání výskytù slova (zvý¹í hodnotu pro
                            // zadaný klíè/slovo pokud záznam existuje,
                            // jinak vytvoøí nový záznam s hodnotou 0 a
                            // tu operace ++ zvý¹í na 1)

        for (auto &mi: m)   // pro v¹echny prvky kontejneru m
            cout << mi.first << "\t" << mi.second << "\n";
            //      klíè/slovo          hodnota/poèet
            // prvky kontejneru typu "map" jsou dvojice (klíè,hodnota)
    }

   Výstupy programù musí být pro stejný vstup stejné (kromì poøadí a pøíli¹
   dlouhých slov).

   Výsledný program se musí jmenovat "wordcount.c".

   Implementujte tabulku s rozptýlenými polo¾kami (hash table) - viz dále.
   Ve¹keré operace s tabulkou budou v samostatné knihovnì (vytvoøte statickou
   i dynamickou/sdílenou verzi).  V knihovnì musí být prakticky ka¾dá funkce ve
   zvlá¹tním modulu -- to napøíklad umo¾ní pøípadnou výmìnu htab_hash_function() ve va¹em
   staticky sestaveném programu. (V dynamicky sestaveném programu je to mo¾né v¾dy.)
   Vyzkou¹ejte si to: definujte svoji verzi htab_hash_function() v programu
   s podmínìným pøekladem -- pou¾ijte #ifdef HASHTEST.

   Knihovna s tabulkou se musí jmenovat
   "libhtab.a" (na Windows je mo¾né i "htab.lib") pro statickou variantu,
   "libhtab.so" (na Windows je mo¾né i "htab.dll") pro sdílenou variantu
   a rozhraní "htab.h".

   Podmínky:
    - Implementace musí být dynamická (malloc/free) a musíte zvládnout
      správu pamìti v C (pou¾ijte valgrind nebo jiný podobný nástroj).

    - Vhodná rozptylovací funkce pro øetìzce je podle literatury
      (http://www.cse.yorku.ca/~oz/hash.html - varianta sdbm):

        size_t htab_hash_function(const char *str) {
          uint32_t h=0;     // musí mít 32 bitù
          const unsigned char *p;
          for(p=(const unsigned char*)str; *p!='\0'; p++)
              h = 65599*h + *p;
          return h;
        }

      její výsledek modulo arr_size urèuje index do tabulky:
        index = (htab_hash_function("mystring") % arr_size);
      Zkuste pou¾ít i jiné podobné funkce a porovnejte efektivitu.

    - Tabulka je (pro knihovnu privátní) struktura obsahující pole seznamù,
      jeho velikost a poèet polo¾ek tabulky v následujícím poøadí:

      +----------+
      | size     | // aktuální poèet záznamù [(key,data),next]
      +----------+
      | arr_size | // velikost pole ukazatelù (poèet polo¾ek)
      +----------+
      | arr_ptr  | // ukazatel na dynamicky alokované pole ukazatelù
      +----------+
        |
        V
      +---+
      |ptr|-->[(key,data),next]-->[(key,data),next]-->[(key,data),next]--|
      +---+
      |ptr|--|
      +---+
      |ptr|-->[(key,data),next]-->[(key,data),next]--|
      +---+
      |ptr|--|
      +---+

      (V obrázku platí velikost .arr_size==4 a poèet polo¾ek .size==5.)
      Polo¾ka .arr_size je velikost dynamicky alokovaného pole ukazatelù.
      Pamì» pro strukturu se dynamicky alokuje a ukazatel na ni se pou¾ívá
      pro identifikaci tabulky.  V programu zvolte vhodnou minimální
      (poèáteèní) velikost pole a v komentáøi zdùvodnìte va¹e rozhodnutí.
      Rozhraní knihovny obsahuje jen _neúplnou_deklaraci_ struktury, definice
      je u¾ivateli knihovny skryta (jde o formu zapouzdøení - "encapsulation").

    - Napi¹te funkce podle následujícího hlavièkového souboru (API):

==================================================================
// htab.h -- rozhraní knihovny htab (øe¹ení IJC-DU2)
// Licence: ¾ádná (Public domain)

// následující øádky zabrání násobnému vlo¾ení:
#ifndef __HTAB_H__
#define __HTAB_H__

#include <string.h>     // size_t
#include <stdbool.h>    // bool

// Tabulka:
struct htab;    // neúplná deklarace struktury - u¾ivatel nevidí obsah
typedef struct htab htab_t;     // typedef podle zadání

// Typy:
typedef const char * htab_key_t;        // typ klíèe
typedef int htab_value_t;               // typ hodnoty

// Dvojice dat v tabulce:
typedef struct htab_pair {
    htab_key_t    key;          // klíè
    htab_value_t  value;        // asociovaná hodnota
} htab_pair_t;                  // typedef podle zadání

// Rozptylovací (hash) funkce (stejná pro v¹echny tabulky v programu)
// Pokud si v programu definujete stejnou funkci, pou¾ije se ta va¹e.
size_t htab_hash_function(htab_key_t str);

// Funkce pro práci s tabulkou:
htab_t *htab_init(size_t n);                    // konstruktor tabulky
size_t htab_size(const htab_t * t);             // poèet záznamù v tabulce
size_t htab_bucket_count(const htab_t * t);     // velikost pole
void htab_resize(htab_t *t, size_t newn);       // zmìna velikosti pole
                                                // (umo¾òuje rezervaci místa)

htab_pair_t * htab_find(htab_t * t, htab_key_t key);  // hledání
htab_pair_t * htab_lookup_add(htab_t * t, htab_key_t key);

bool htab_erase(htab_t * t, htab_key_t key);    // ru¹í zadaný záznam

// for_each: projde v¹echny záznamy a zavolá na nì funkci f
// Pozor: f nesmí mìnit klíè .key ani pøidávat/ru¹it polo¾ky
void htab_for_each(const htab_t * t, void (*f)(htab_pair_t *data));

void htab_clear(htab_t * t);    // ru¹í v¹echny záznamy
void htab_free(htab_t * t);     // destruktor tabulky

#endif // __HTAB_H__
==================================================================

      Hlavièkový soubor mù¾ete celý pøevzít (je "Public domain").

    - Struèný popis základních funkcí:

        t=htab_init(num)          konstruktor: vytvoøení a inicializace tabulky
                                  num = poèet prvkù pole (.arr_size)

        size_t s=htab_size(t)           vrátí poèet prvkù tabulky (.size)

        size_t n=htab_bucket_count(t)   vrátí poèet prvkù pole (.arr_size)

        htab_resize(t,newnum)     Zmìní velikost alokovaného pole a pøesune
                                  polo¾ky z pùvodních seznamù.
                                  Pokud alokace pole sel¾e, nemìní nic.

        ptr=htab_find(t,key)         vyhledávání - viz dále
        ptr=htab_lookup_add(t,key)   vyhledávání+pøidání - viz dále

        b=htab_erase(t,key)       zru¹ení záznamu se zadaným klíèem (úspìch:true)
                                  Kdy¾ prùmìrná délka seznamù klesne pod vámi
                                  definovaný limit AVG_LEN_MIN provede operaci
                                  htab_resize na polovièní velikost.

        htab_for_each(t,funkce)   projde v¹echny záznamy, na ka¾dý zavolá funkci
                                  (pozor na mo¾né zmìny tabulky!)

        htab_clear(t)             zru¹ení v¹ech polo¾ek, tabulka zùstane prázdná

        htab_free(t)              destruktor: zru¹ení tabulky (volá htab_clear())

      kde t,t2    je ukazatel na tabulku (typu htab_t *),
          b       je typu bool,
          ptr     je ukazatel na záznam (polo¾ku tabulky {klíè,hodnota}),

    - Vhodnì zvolte typy parametrù funkcí (vèetnì pou¾ití const).

    - Záznam [(key,value),next] je typu
          struct htab_item
      a obsahuje polo¾ky:
          next ... ukazatel na dal¹í záznam
          struct htab_pair ... veøejná struktura s polo¾kami:
            key ..... ukazatel na dynamicky alokovaný øetìzec,
            value ... asociovaná data = poèet výskytù
      Tento záznam je definován v privátním hlavièkovém souboru pro v¹echny
      moduly tabulky a není dostupný pøi pou¾ití knihovny ("Opaque data type").
      U¾ivatel pou¾ívá ukazatel na vnoøenou strukturu htab_pair_t.

    - Funkce
        htab_pair_t *htab_find(htab_t *t, htab_key_t key);
      V tabulce  t  vyhledá záznam odpovídající øetìzci  key  a
        - pokud jej nalezne, vrátí ukazatel na záznam
        - pokud nenalezne, vrátí NULL

    - Funkce
        htab_pair_t htab_lookup_add(htab_t *t, htab_key_t key);
      V tabulce  t  vyhledá záznam odpovídající øetìzci  key  a
        - pokud jej nalezne, vrátí ukazatel na záznam
        - pokud nenalezne, automaticky pøidá záznam a vrátí ukazatel
          Kdy¾ prùmìrná délka seznamù pøesáhne vámi definovaný limit
          AVG_LEN_MAX provede operaci htab_resize na dvojnásobnou velikost.
      Poznámka: Dobøe promyslete chování této funkce k parametru key.
      Poznámka: podobnì se chová C++ operator[] pro std::unordered_map

    - Kdy¾ htab_init nebo htab_lookup_add nemohou alokovat pamì»,
      vrací NULL (a u¾ivatel musí testovat výsledek tìchto operací)
      Poznámka: C++ na to pou¾ívá výjimky ("exceptions").


    Napi¹te funkci

        int read_word(char *s, int max, FILE *f);

      která ète jedno slovo ze souboru f do zadaného pole znakù
      a vrátí délku slova (z del¹ích slov naète prvních max-1 znakù,
      a zbytek pøeskoèí). Funkce vrací EOF, pokud je konec souboru.
      Umístìte ji do zvlá¹tního modulu "io.c" (nepatøí do knihovny).
      Poznámka: Slovo je souvislá posloupnost znakù oddìlená isspace znaky.

    Omezení: øe¹ení v C bude tisknout jinak uspoøádaný výstup
      a je povoleno pou¾ít implementaèní limit na maximální
      délku slova (napø. 127 znakù), del¹í slova se ZKRÁTÍ a program
      pøi prvním del¹ím slovu vytiskne varování na stderr (max 1 varování).

    Poznámka: Vhodný soubor pro testování je napøíklad seznam slov
              v souboru /usr/share/dict/words
              nebo texty z http://www.gutenberg.org/
              pøípadnì výsledek pøíkazu:  "seq 1000000 2000000|shuf"

(10b)

Pou¾ijte implicitní lokalizaci (= nevolat setlocale()). Zamyslete se nad tím,
jaké problémy by pøineslo pou¾ití UTF-8 pøi zapnuté lokalizaci s tímto
dnes bì¾nì pou¾ívaným kódováním.

Napi¹te soubor Makefile tak, aby pøíkaz make vytvoøil programy
"tail", "wordcount", "wordcount-dynamic" a knihovny "libhtab.a",
"libhtab.so" (nebo "htab.dll" atd.).

Program "wordcount" musí být staticky sestaven s knihovnou "libhtab.a".

Program "wordcount-dynamic" musí být sestaven s knihovnou "libhtab.so".
Tento program otestujte se stejnými vstupy jako u staticky sestavené verze.

Vyzkou¹ejte si rùzné hodnoty AVG_LEN_{MIN|MAX} a odhadnìte jejich rozumnou
velikost pro optimální výkonnostní charakteristiky (htab_resize se nesmí
provádìt pøíli¹ èasto). Zamyslete se, jak se zhor¹í prùmìrná výpoèetní
nároènost (slo¾itost) operace vlo¾ení dal¹ího záznamu vzhledem k nutnosti
provádìt htab_resize.

Porovnejte efektivitu obou (C i C++) implementací (viz napø. pøíkaz time)
a zamyslete se nad výsledky (pozor na vliv vyrovnávacích pamì»í atd.)
Také si zkuste pøeklad s optimalizací i bez ní (-O2, -O0) a porovnejte
efektivitu pro vhodný vstup.

Poznámky:
 - pro testy wordcount-dynamic na linuxu budete potøebovat nastavit
      LD_LIBRARY_PATH="."   (viz "man ld.so" a odpovídající pøedná¹ka)
 - Ètìte pokyny pro vypracování domácích úkolù (viz dále)

----------------------------------------------------------------

Obecné pokyny pro vypracování domácích úkolù

*  Pro úkoly v jazyce C pou¾ívejte ISO C11 (soubory *.c)
   Pro úkoly v jazyce C++ pou¾ívejte ISO C++17 (soubory *.cc)
   Pou¾ití nepøenositelných konstrukcí v programech není dovoleno.

*  Úkoly zkontrolujte pøekladaèem napøíklad takto:
      gcc -std=c11 -pedantic -Wall -Wextra priklad1.c
      g++ -std=c++17 -pedantic -Wall priklad.cc
   Místo gcc mù¾ete pou¾ít i jiný pøekladaè - podle va¹eho prostøedí.
   V  souvislosti s tím napi¹te do poznámky na zaèátku
   souboru jméno a verzi pøekladaèe, kterým byl program pøelo¾en
   (implicitní je GCC `g++ --version` na poèítaèi merlin).

*  Programy  pi¹te, pokud je to mo¾né, do jednoho zdrojového
   souboru. Dodr¾ujte pøedepsaná jména souborù.

*  Na zaèátek ka¾dého souboru napi¹te poznámku, která bude
   obsahovat jméno, fakultu, oznaèení pøíkladu a datum.

* Úkoly je nutné zabalit programem zip takto:
       zip xnovak99.zip *.c *.cc *.h Makefile

  Jméno xnovak99 nahradíte vlastním. Formát souboru bude ZIP.
  Archiv neobsahuje adresáøe.  Ka¾dý si zkontroluje obsah ZIP archivu jeho
  rozbalením v prázdném adresáøi a napsáním "make".

* Posílejte pouze nezbytnì nutné soubory -- ne *.EXE !

* Øe¹ení se odevzdává elektronicky v IS FIT

* Úkoly neodevzdané v termínu (podle WIS) budou za 0 bodù.

* Opsané úkoly budou hodnoceny 0 bodù pro v¹echny zùèastnìné
  a to bez výjimky (+ bonus v podobì náv¹tìvy u disciplinární komise).


</xmp>
<hr>
<address>
Poslední modifikace: <!-- begin flastmod -->
22. March 2022<!-- end -->
<br>
Pokud naleznete na této stránce chybu, oznamte to dopisem na adresu
peringer AT fit.vutbr.cz
</address>



</body></html>